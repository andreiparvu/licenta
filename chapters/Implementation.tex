\chapter{Architecture}
\label{chap:implementation}

\section{Basic structure}

To illustrate the functionality of the described algorithm, I have designed a basic application which maintains a data base of images and, for a given query image, can retrieve the best match between
the query and the image set.\\
The basic structure of the application is shown in Figure~\ref{fig:basicStructure}: all the queries are received by the Load Balancer, which acts like a front end processor and distributes in a round-robin fashion the queries to several Map Reduce servers. When these servers receive a query, they distribute it to the associated Image Servers, which contain the descriptors for various sets of images. The Image Servers compute the top $T$ most similar images and then they send it back to the Map Reducer, which extracts the best images from the received responses and sends them back to the Load Balancer. There are several advantages of separating the image servers from the FEP. First of all, it allows load balancing: the FEP can maintain a queue of requests and the server with the least work to do can pick it up and process it. Secondly, it allows different types of image servers to be tested, by easily inserting and removing the image server module.\\
The querying instance type is not particularly important, it can be either a simple web page or a browser extension (e.g. Google Chrome extension).

\tikzstyle{block3} = [rectangle, draw, fill=blue!20, 
    text width=5.5em, text centered, rounded corners, minimum height=3em]
\tikzstyle{line} = [draw, -latex']
\tikzstyle{cloud} = [draw, ellipse,fill=red!20, node distance=1.5cm,
    minimum height=0.5em]
\tikzstyle{block2} = [rectangle, draw, fill=blue!30, 
    text width=5.5em, text centered, rounded corners, minimum height=4em, node distance=3cm]
\tikzstyle{block1} = [rectangle, draw, fill=blue!50, 
    text width=5.5em, text centered, rounded corners, minimum height=3em]
    
\begin{figure}[ht!]
\centering

\begin{tikzpicture}[node distance = 2cm, baseline=1em]
    % Place nodes   
    \node [cloud] (query1) {image query};
    \node [cloud, below of = query1] (query2) {image query};
    \node [cloud, below of = query2] (query3) {image query};
    \node [cloud, below of = query3] (query4) {image query};
    \node [cloud, below of = query4] (query5) {image query};
    \node [block1, right of = query3, node distance = 4cm] (loadbalancer) {Load Balancer};
    \node [block2, right of = loadbalancer, node distance = 3cm] (mapreducer1) {MapReducer};
    \node [block2, below of = mapreducer1] (mapreducer2) {MapReducer};
    \node [block2, above of = mapreducer1] (mapreducer3) {MapReducer};
    \node [block3, right of = mapreducer1, node distance = 3cm] (server1) {Image Server};
    \node [block3, below of = server1] (server2) {Image Server};
    \node [block3, above of = server1] (server3) {Image Server};
    \node [block3, below of = server2] (server4) {Image Server};
    \node [block3, above of = server3] (server5) {Image Server};
    % Draw edges
    \path [line] (query1) -- (loadbalancer);
    \path [line] (query2) -- (loadbalancer);
    \path [line] (query3) -- (loadbalancer);
    \path [line] (query4) -- (loadbalancer);
    \path [line] (query5) -- (loadbalancer);
    \path [line] (loadbalancer) -- (mapreducer1);
    \path [line] (loadbalancer) -- (mapreducer2);
    \path [line] (loadbalancer) -- (mapreducer3);
    \path [line] (mapreducer1) -- (server1);
    \path [line] (mapreducer1) -- (server2);
    \path [line] (mapreducer1) -- (server3);
    \path [line] (mapreducer1) -- (server4);
    \path [line] (mapreducer1) -- (server5);
    
\end{tikzpicture}
\caption{Basic structure}
\label{fig:basicStructure}
\end{figure}

\section{Load Balancer}

The Load Balancer acts as a classical server. It uses socket communication in order to receive the queries and send them in a round-robin order to the connected Map Reducers. When a response is received from the Map Reducer the Load Balancer sends it back to the entity that has made the given query.

\section{Map Reducer}

The Map Reducer maintains a set of connections to a number of associated Image Servers to which it broadcasts a received query. The Map Reducer waits for the response from the servers (in the meantime it does not process other queries), and combines the received results, by selecting the images with the highest $image\ pair\ score$ from all the images returned by the Image Servers.

\section{Image Server}

\subsection{Linear Server}
	The first type of server uses the $linear\ algorithm$ described in \nameref{chap:design}. It stores the list of images that form our database and applies the $linear\ algorithm$ a certain query arrives from the Map Reducer.
	
\subsection{KD-tree Server}
	The second type of server uses the $kdtree\ algorithm$ described in \nameref{chap:design}. At initialization time the server reads a given list of images from our database, computes its descriptors and applies the above mentioned algorithm when a query arrives from the Map Reducer. The resulting KD-tree is maintained in memory throughout the incoming queries and it it used to find the top $T$ most similar images and return them to the Map Reducer.
	
\section{Technologies}

The majority of our code, Load Balancer, Map Reducer and Image Serves, is written in C++, because of the high computation nature of our problem. For the image processing and associated algorithm we have used OpenCV version 2.4.8.

\subsection{Image Storing}

We determined that it is better to store only the urls of the images used in out database (not the actual images), the Image Servers downloading an image whenever they need to use it (at initialization time or at query time). The downloading is done using a CURL library for C++.\\
Also, to avoid computing the SIFT descriptors for all the images every time we start an Image Server we opted to retain those descriptors in our database, and only load them when needed.\\
We maintain a Redis server on a machine which stores all the urls and the descriptors of the images, and which we can query using a specific C++ library.

\subsection{Process Communication}

For the process communication, we opted to use sockets so that the various servers can reside on different machines. ZeroMQ sockets looked liked the best option, because of their robustness, small running time, auto-handling of connection failures and different types (DEALER, PUB-SUB, PUSH-PULL, ROUTER, etc.).


